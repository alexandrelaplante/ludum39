<!DOCTYPE HTML>
<html>
    <head>
        <title>phaser - hello world</title>
    </head>
    <div id="chargingState"></div>
    <script>
        var chargingStateEl = document.getElementById('chargingState');

        function updateBatteryUI(battery) {
            if (battery.charging === true) {
                chargingStateEl.textContent = 'Charging';
            } else if (battery.charging === false) {
                chargingStateEl.textContent = 'Discharging';
            }
        }

        function monitorBattery(battery) {
            // Update the initial UI.
            updateBatteryUI(battery);

            // Monitor for futher updates.
            battery.addEventListener(
                'chargingchange',
                updateBatteryUI.bind(null, battery),
            );
        }

        if ('getBattery' in navigator) {
            navigator.getBattery().then(monitorBattery);
        } else {
            ChromeSamples.setStatus('The Battery Status API is not supported on ' +
                'this platform.');
        }
    </script>
    <script src="phaser.js"></script>
    <script>

        var TILE_WIDTH = 16;
        var SCALE = 3.5

        var game = new Phaser.Game(
            800,
            600,
            Phaser.AUTO,
            'ludum39',
            { preload: preload, create: create, update: update, render: render }
        );

        function preload() {
            game.load.tilemap('map', 'maps/map1.json', null, Phaser.Tilemap.TILED_JSON);
            game.load.image('dungeon_sheet', 'dungeon_sheet.png');
            game.load.spritesheet('knight', 'knightanimation.png', 12, 16);
        }

        var map;
        var floorLayer;
        var wallLayer;
        var forgroundLayer;
        var marker;

        var knight;
        var cursors;
        var currentDataString;

        function create() {
            Phaser.Canvas.setImageRenderingCrisp(game.canvas)
            PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST

            game.world.scale.setTo(SCALE, SCALE);
            game.physics.startSystem(Phaser.Physics.ARCADE);

            map = game.add.tilemap('map');

            map.addTilesetImage('dungeon_sheet');

            // map.setCollisionBetween(1, 12);

            floorLayer = map.createLayer('Floor');
            wallLayer = map.createLayer('Walls');
            forgroundLayer = map.createLayer('Forground');

            floorLayer.resizeWorld();
            wallLayer.resizeWorld();
            forgroundLayer.resizeWorld();

            //  Our painting marker
            marker = game.add.graphics();
            marker.lineStyle(2, 0xffffff, 1);
            marker.drawRect(0, 0, TILE_WIDTH, TILE_WIDTH);

            game.input.addMoveCallback(updateMarker, this);

            game.input.onDown.add(getTilePropertiesFromPointer, this);

            knight = game.add.sprite(3*TILE_WIDTH+2, 5*TILE_WIDTH, 'knight');
            game.physics.arcade.enable(knight);
            knight.targetX = knight.body.x;
            knight.targetY = knight.body.y;
            // knight.body.collideWorldBounds = true;
            knight.frame = 0;
            knight.animations.add('up', [0, 1, 2], 5, true);
            knight.animations.play('up');

            cursors = game.input.keyboard.createCursorKeys();

            function moveX(direction) {
                targetX = knight.targetX + direction*TILE_WIDTH;
                targetY = knight.targetY;

                if (knight.body.x == knight.targetX * SCALE && !isWall(targetX, targetY)) {
                    knight.targetX = targetX;
                }
            }

            function moveY(direction) {
                targetX = knight.targetX;
                targetY = knight.targetY + direction*TILE_WIDTH;

                if (knight.body.y == knight.targetY * SCALE && !isWall(targetX, targetY)) {
                    knight.targetY = targetY;
                }
            }

            cursors.left.onDown.add(function() {
                return moveX(-1);
            }, this);

            cursors.right.onDown.add(function() {
                return moveX(1)
            }, this);

            cursors.up.onDown.add(function() {
                return moveY(-1);
            }, this);

            cursors.down.onDown.add(function() {
                return moveY(1);
            }, this);
        }

        function getTileProperties(x, y) {

            var x = forgroundLayer.getTileX(x);
            var y = forgroundLayer.getTileY(y);

            var tile = map.getTile(x, y, forgroundLayer);

            // Note: JSON.stringify will convert the object tile properties to a string
            currentDataString = JSON.stringify( tile.properties );

        }

        function isWall(x, y) {

            var x = wallLayer.getTileX(x);
            var y = wallLayer.getTileY(y);

            var tile = map.getTile(x, y, wallLayer);

            // Note: JSON.stringify will convert the object tile properties to a string
            return tile != null;

        }

        function getTilePropertiesFromPointer() {

            var x = (game.input.activePointer.worldX / SCALE);
            var y = (game.input.activePointer.worldY / SCALE);

            return getTileProperties(x, y);
        }

        function updateMarker() {

            marker.x = forgroundLayer.getTileX(game.input.activePointer.worldX / SCALE) * TILE_WIDTH ;
            marker.y = forgroundLayer.getTileY(game.input.activePointer.worldY / SCALE) * TILE_WIDTH ;

        }

        function update() {

            game.physics.arcade.collide(knight);

            if (knight.body.x < knight.targetX * SCALE) {
                knight.body.x += 1;
            } else if (knight.body.x > knight.targetX * SCALE) {
                knight.body.x -= 1;
            }

            if (knight.body.y < knight.targetY * SCALE) {
                knight.body.y += 1;
            } else if (knight.body.y > knight.targetY * SCALE) {
                knight.body.y -= 1;
            }

        }

        function render() {

            if(currentDataString){
                game.debug.text('Tile properties: ' + currentDataString, TILE_WIDTH, 550);
            } else {
                game.debug.text("Click on a tile to reveal the properties of the tile", TILE_WIDTH, 550);
            }
        }

    </script>
</html>
