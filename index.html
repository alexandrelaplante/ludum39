<!DOCTYPE HTML>
<html>
    <head>
        <title>phaser - hello world</title>
    </head>
    <div id="chargingState"></div>
    <script>
        var chargingStateEl = document.getElementById('chargingState');

        function updateBatteryUI(battery) {
            if (battery.charging === true) {
                chargingStateEl.textContent = 'Charging';
            } else if (battery.charging === false) {
                chargingStateEl.textContent = 'Discharging';
                return 'Discharging';
            }
        }

        function monitorBattery(battery) {
            // Update the initial UI.
            updateBatteryUI(battery);

            // Monitor for futher updates.
            battery.addEventListener(
                'chargingchange',
                updateBatteryUI.bind(null, battery),
            );

            window.battery = battery;
        }

        if ('getBattery' in navigator) {
            navigator.getBattery().then(monitorBattery);
        } else {
            ChromeSamples.setStatus('The Battery Status API is not supported on ' +
                'this platform.');
        }
    </script>
    <script src="phaser.js"></script>
    <script>

        var TILE_WIDTH = 16;
        var SCALE = 3.5

        // Accomodate for sprite offset
        var X_OFFSET = 2;

        var game = new Phaser.Game(
            800,
            600,
            Phaser.AUTO,
            'ludum39',
            { preload: preload, create: create, update: update, render: render }
        );

        function preload() {
            game.load.tilemap('map', 'maps/map1.json', null, Phaser.Tilemap.TILED_JSON);
            game.load.tilemap('map2', 'maps/map2.json', null, Phaser.Tilemap.TILED_JSON);

            game.load.image('dungeon_sheet', 'dungeon_sheet.png');
            game.load.spritesheet('knight', 'knightanimation.png', 12, 16);
            game.load.spritesheet('powered_door', 'powered_door.png', 48, 32);
        }

        var map1;
        var map2;
        var marker;
        var oldBatteryState;

        var knight;
        var cursors;
        var currentDataString;
        var currentMap;

        function renderMap(map) {
            map.floorLayer = map.createLayer('Floor');
            map.wallLayer = map.createLayer('Walls');
            map.forgroundLayer = map.createLayer('Forground');
            map.animatedLayer = map.createLayer('Animated');

            map.floorLayer.resizeWorld();
            map.wallLayer.resizeWorld();
            map.forgroundLayer.resizeWorld();
            map.animatedLayer.resizeWorld();

            //  Our painting marker
            if (marker) {
                marker.destroy();
            }
            marker = game.add.graphics();
            marker.lineStyle(2, 0xffffff, 1);
            marker.drawRect(0, 0, TILE_WIDTH, TILE_WIDTH);

            currentMap = map;
        }

        function create() {
            Phaser.Canvas.setImageRenderingCrisp(game.canvas)
            PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST

            // scale the game 4x
            game.scale.scaleMode = Phaser.ScaleManager.USER_SCALE;
            game.scale.setUserScale(SCALE, SCALE);

            // enable crisp rendering
            game.renderer.renderSession.roundPixels = true;
            Phaser.Canvas.setImageRenderingCrisp(this.game.canvas);

            // game.world.scale.setTo(SCALE, SCALE);
            game.physics.startSystem(Phaser.Physics.ARCADE);

            map1 = game.add.tilemap('map');
            map2 = game.add.tilemap('map2');
            map1.addTilesetImage('dungeon_sheet');
            map2.addTilesetImage('dungeon_sheet');

            renderMap(map1);

            map1.nextMap = map2;
            map1.goalX = 3*TILE_WIDTH + X_OFFSET;
            map1.goalY = 3*TILE_WIDTH;

            map2.goalX = 0;
            map2.goalY = 0;

            game.input.addMoveCallback(updateMarker, this);

            game.input.onDown.add(getTilePropertiesFromPointer, this);

            knight = game.add.sprite(3*TILE_WIDTH+X_OFFSET, 5*TILE_WIDTH, 'knight');
            game.physics.arcade.enable(knight);
            knight.targetX = knight.body.x;
            knight.targetY = knight.body.y;
            // knight.body.collideWorldBounds = true;
            knight.frame = 0;
            knight.animations.add('up', [0, 1, 2], 8, true);
            knight.animations.add('down', [12, 13, 14], 8, true);
            knight.animations.add('left', [18, 19, 20], 8, true);
            knight.animations.add('right', [6, 7, 8], 8, true);

            map1.door = game.add.sprite(2*TILE_WIDTH, 2*TILE_WIDTH, 'powered_door');
            map1.door.frame = 0;
            map1.door.animations.add('open', [0, 1, 2, 3, 4], 8, false);
            map1.door.animations.add('close', [4, 3, 2, 1, 0], 8, false);
            map1.door.animations.play('close');

            cursors = game.input.keyboard.createCursorKeys();

            function move(targetX, targetY, animation) {

                if (isMoving()) {
                    return;
                }

                knight.animations.play(animation);

                if (!isWall(targetX, targetY)) {
                    knight.targetX = targetX;
                    knight.targetY = targetY;
                    s = game.add.tween(knight.body);
                    s.to({x: targetX, y:targetY}, 500, Phaser.Easing.Linear.None);
                    s.onComplete.addOnce(function(){
                        knight.animations.stop();
                    }, this);
                    s.start();
                }
            }

            cursors.left.onDown.add(function() {
                var targetX = knight.targetX - TILE_WIDTH;
                var targetY = knight.targetY;
                return move(targetX, targetY, 'left');
            }, this);

            cursors.right.onDown.add(function() {
                var targetX = knight.targetX + TILE_WIDTH;
                var targetY = knight.targetY;
                return move(targetX, targetY, 'right');
            }, this);

            cursors.up.onDown.add(function() {
                var targetX = knight.targetX;
                var targetY = knight.targetY - TILE_WIDTH;
                return move(targetX, targetY, 'up');
            }, this);

            cursors.down.onDown.add(function() {
                var targetX = knight.targetX;
                var targetY = knight.targetY + TILE_WIDTH;
                return move(targetX, targetY, 'down');
            }, this);
        }

        function isMoving() {
            return (
                knight.body.x != knight.targetX
                || knight.body.y != knight.targetY
            );
        }

        function getTileProperties(x, y) {

            var x = currentMap.forgroundLayer.getTileX(x);
            var y = currentMap.forgroundLayer.getTileY(y);

            var tile = currentMap.getTile(x, y, currentMap.forgroundLayer);

            // Note: JSON.stringify will convert the object tile properties to a string
            currentDataString = JSON.stringify( tile.properties );

        }

        function isWall(x, y) {

            var x = currentMap.wallLayer.getTileX(x);
            var y = currentMap.wallLayer.getTileY(y);

            var tile = currentMap.getTile(x, y, currentMap.wallLayer);

            var closedDoor = currentMap.getTile(x, y, currentMap.animatedLayer) && !currentMap.door.isOpen;

            return tile != null || closedDoor;
        }

        function getTilePropertiesFromPointer() {

            var x = (game.input.activePointer.worldX);
            var y = (game.input.activePointer.worldY);

            return getTileProperties(x, y);
        }

        function updateMarker() {

            marker.x = currentMap.forgroundLayer.getTileX(game.input.activePointer.worldX) * TILE_WIDTH ;
            marker.y = currentMap.forgroundLayer.getTileY(game.input.activePointer.worldY) * TILE_WIDTH ;

        }

        function renderNextMap() {
            currentMap.floorLayer.destroy();
            currentMap.wallLayer.destroy();
            currentMap.forgroundLayer.destroy();
            currentMap.animatedLayer.destroy()
            knight.destroy();

            nextMap = currentMap.nextMap;
            renderMap(nextMap);

            knight = game.add.sprite(3*TILE_WIDTH+X_OFFSET, 5*TILE_WIDTH, 'knight');
            game.physics.arcade.enable(knight);
            knight.targetX = knight.body.x;
            knight.targetY = knight.body.y;
            knight.frame = 0;
            knight.animations.add('up', [0, 1, 2], 8, true);
            knight.animations.add('down', [12, 13, 14], 8, true);
            knight.animations.add('left', [18, 19, 20], 8, true);
            knight.animations.add('right', [6, 7, 8], 8, true);
        };

        function update() {
            if (knight.body.x == currentMap.goalX && knight.body.y == currentMap.goalY) {
                renderNextMap();
            }
            if (!isMoving()){
                knight.animations.stop()
            }

            newBatteryState = window.battery.charging;
            if (oldBatteryState != newBatteryState) {
                oldBatteryState = newBatteryState;
                if (newBatteryState) {
                    currentMap.door.animations.play('open');
                    currentMap.door.isOpen = true;
                } else {
                    currentMap.door.animations.play('close');
                    currentMap.door.isOpen = false;
                }
            }

        }

        function render() {

            if(currentDataString){
                game.debug.text('Tile properties: ' + currentDataString, TILE_WIDTH, 550);
            } else {
                game.debug.text("Click on a tile to reveal the properties of the tile", TILE_WIDTH, 550);
            }
        }

    </script>
</html>
