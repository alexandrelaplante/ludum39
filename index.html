<!DOCTYPE HTML>
<html>
    <head>
        <title>phaser - hello world</title>
    </head>
    <div id="chargingState"></div>
    <script>
        var chargingStateEl = document.getElementById('chargingState');

        function updateBatteryUI(battery) {
            if (battery.charging === true) {
                chargingStateEl.textContent = 'Charging';
            } else if (battery.charging === false) {
                chargingStateEl.textContent = 'Discharging';
            }
        }

        function monitorBattery(battery) {
            // Update the initial UI.
            updateBatteryUI(battery);

            // Monitor for futher updates.
            battery.addEventListener(
                'chargingchange',
                updateBatteryUI.bind(null, battery),
            );
        }

        if ('getBattery' in navigator) {
            navigator.getBattery().then(monitorBattery);
        } else {
            ChromeSamples.setStatus('The Battery Status API is not supported on ' +
                'this platform.');
        }
    </script>
    <script src="phaser.js"></script>
    <script>

        var TILE_WIDTH = 16;
        var SCALE = 3.5

        var game = new Phaser.Game(
            800,
            600,
            Phaser.AUTO,
            'ludum39',
            { preload: preload, create: create, update: update, render: render }
        );

        function preload() {
            game.load.tilemap('map', 'maps/map1.json', null, Phaser.Tilemap.TILED_JSON);
            game.load.image('dungeon_sheet', 'dungeon_sheet.png');
            game.load.spritesheet('knight', 'knightanimation.png', 12, 16);
        }

        var map;
        var floorLayer;
        var wallLayer;
        var forgroundLayer;
        var marker;

        var knight;
        var cursors;
        var currentDataString;

        function create() {
            Phaser.Canvas.setImageRenderingCrisp(game.canvas)
            PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST

            game.world.scale.setTo(SCALE, SCALE);
            game.physics.startSystem(Phaser.Physics.ARCADE);

            map = game.add.tilemap('map');

            map.addTilesetImage('dungeon_sheet');

            // map.setCollisionBetween(1, 12);

            floorLayer = map.createLayer('Floor');
            wallLayer = map.createLayer('Walls');
            forgroundLayer = map.createLayer('Forground');

            floorLayer.resizeWorld();
            wallLayer.resizeWorld();
            forgroundLayer.resizeWorld();

            //  Our painting marker
            marker = game.add.graphics();
            marker.lineStyle(2, 0xffffff, 1);
            marker.drawRect(0, 0, TILE_WIDTH, TILE_WIDTH);

            game.input.addMoveCallback(updateMarker, this);

            game.input.onDown.add(getTileProperties, this);

            knight = game.add.sprite(3*TILE_WIDTH+2, 5*TILE_WIDTH, 'knight');
            game.physics.arcade.enable(knight);
            knight.targetX = knight.body.x;
            // knight.body.collideWorldBounds = true;
            knight.frame = 0;
            knight.animations.add('up', [0, 1, 2], 5, true);
            knight.animations.play('up');

            cursors = game.input.keyboard.createCursorKeys();

            cursors.left.onDown.add(function() {
                console.log('ON DOWNNN');
                if (knight.body.x == knight.targetX) {
                    knight.targetX -= TILE_WIDTH;
                }
            }, this);
            console.log('END OF CREATE' + knight.targetX, knight.body.x);
        }

        function getTileProperties() {

            var x = forgroundLayer.getTileX(game.input.activePointer.worldX / SCALE);
            var y = forgroundLayer.getTileY(game.input.activePointer.worldY / SCALE);

            var tile = map.getTile(x, y, forgroundLayer);

            // Note: JSON.stringify will convert the object tile properties to a string
            currentDataString = JSON.stringify( tile.properties );

            tile.properties.wibble = true;

        }

        function updateMarker() {

            marker.x = forgroundLayer.getTileX(game.input.activePointer.worldX / SCALE) * TILE_WIDTH ;
            marker.y = forgroundLayer.getTileY(game.input.activePointer.worldY / SCALE) * TILE_WIDTH ;

        }

        function update() {

            game.physics.arcade.collide(knight);

            if (knight.targetX != knight.body.x) {
                if (knight.targetX > knight.body.x) {
                    knight.body.x -= 5;
                } else if (knight.targetX < knight.body.x) {
                    console.log(knight.targetX, knight.body.x);
                    debugger;
                    knight.body.x += 5;
                }
            }



            // if (cursors.left.onDown)
            // {
            //     knight.targetX = knight.body.x -= TILE_WIDTH;
            //     // game.camera.x -= 4;
            // }
            // else if (cursors.right.isDown)
            // {
            //     // game.camera.x += 4;
            // }
            //
            // if (cursors.up.isDown)
            // {
            //     // game.camera.y -= 4;
            // }
            // else if (cursors.down.isDown)
            // {
            //     // game.camera.y += 4;
            // }

        }

        function render() {

            if(currentDataString){
                game.debug.text('Tile properties: ' + currentDataString, TILE_WIDTH, 550);
            } else {
                game.debug.text("Click on a tile to reveal the properties of the tile", TILE_WIDTH, 550);
            }
        }

    </script>
</html>
