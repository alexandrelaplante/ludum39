<!DOCTYPE HTML>
<html>
    <head>
        <title>phaser - hello world</title>
    </head>
    <div id="chargingState"></div>
    <script>
        var chargingStateEl = document.getElementById('chargingState');

        function updateBatteryUI(battery) {
            if (battery.charging === true) {
                chargingStateEl.textContent = 'Charging';
                return 'Charging';
            } else if (battery.charging === false) {
                chargingStateEl.textContent = 'Discharging';
                return 'Discharging';
            }
        }

        function monitorBattery(battery) {
            // Update the initial UI.
            updateBatteryUI(battery);

            // Monitor for futher updates.
            battery.addEventListener(
                'chargingchange',
                updateBatteryUI.bind(null, battery),
            );
        }

        if ('getBattery' in navigator) {
            navigator.getBattery().then(monitorBattery);
        } else {
            ChromeSamples.setStatus('The Battery Status API is not supported on ' +
                'this platform.');
        }
    </script>
    <script src="phaser.js"></script>
    <script>

        var TILE_WIDTH = 16;
        var SCALE = 3.5

        var game = new Phaser.Game(
            800,
            600,
            Phaser.AUTO,
            'ludum39',
            { preload: preload, create: create, update: update, render: render }
        );

        function preload() {
            game.load.tilemap('map', 'maps/map1.json', null, Phaser.Tilemap.TILED_JSON);
            game.load.image('dungeon_sheet', 'dungeon_sheet.png');
            game.load.spritesheet('knight', 'knightanimation.png', 12, 16);
            game.load.spritesheet('powered_door', 'powered_door.png', 48, 32);
        }

        var map;
        var floorLayer;
        var wallLayer;
        var forgroundLayer;
        var marker;
        var oldBatteryState;

        var knight;
        var door;
        var cursors;
        var currentDataString;

        function create() {
            Phaser.Canvas.setImageRenderingCrisp(game.canvas)
            PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST

            // scale the game 4x
            game.scale.scaleMode = Phaser.ScaleManager.USER_SCALE;
            game.scale.setUserScale(SCALE, SCALE);

            // enable crisp rendering
            game.renderer.renderSession.roundPixels = true;
            Phaser.Canvas.setImageRenderingCrisp(this.game.canvas);

            // game.world.scale.setTo(SCALE, SCALE);
            game.physics.startSystem(Phaser.Physics.ARCADE);

            map = game.add.tilemap('map');

            map.addTilesetImage('dungeon_sheet');

            // map.setCollisionBetween(1, 12);

            floorLayer = map.createLayer('Floor');
            wallLayer = map.createLayer('Walls');
            forgroundLayer = map.createLayer('Forground');

            floorLayer.resizeWorld();
            wallLayer.resizeWorld();
            forgroundLayer.resizeWorld();

            //  Our painting marker
            marker = game.add.graphics();
            marker.lineStyle(2, 0xffffff, 1);
            marker.drawRect(0, 0, TILE_WIDTH, TILE_WIDTH);

            game.input.addMoveCallback(updateMarker, this);

            game.input.onDown.add(getTilePropertiesFromPointer, this);

            knight = game.add.sprite(3*TILE_WIDTH+2, 5*TILE_WIDTH, 'knight');
            game.physics.arcade.enable(knight);
            knight.targetX = knight.body.x;
            knight.targetY = knight.body.y;
            // knight.body.collideWorldBounds = true;
            knight.frame = 0;
            knight.animations.add('up', [0, 1, 2], 8, true);
            knight.animations.add('down', [12, 13, 14], 8, true);
            knight.animations.add('left', [18, 19, 20], 8, true);
            knight.animations.add('right', [6, 7, 8], 8, true);

            door = game.add.sprite(2*TILE_WIDTH, 2*TILE_WIDTH, 'powered_door');
            door.frame = 0;
            door.animations.add('open', [0, 1, 2, 3, 4], 8, false);
            door.animations.add('close', [4, 3, 2, 1, 0], 8, false);
            door.animations.play('close');

            cursors = game.input.keyboard.createCursorKeys();

            function move(targetX, targetY, animation) {

                if (isMoving()) {
                    return;
                }

                knight.animations.play(animation);

                if (!isWall(targetX, targetY)) {
                    knight.targetX = targetX;
                    knight.targetY = targetY;
                    s = game.add.tween(knight.body);
                    s.to({x: targetX, y:targetY}, 500, Phaser.Easing.Linear.None);
                    s.onComplete.addOnce(function(){
                        knight.animations.stop();
                    }, this);
                    s.start();
                }
            }

            cursors.left.onDown.add(function() {
                var targetX = knight.targetX - TILE_WIDTH;
                var targetY = knight.targetY;
                return move(targetX, targetY, 'left');
            }, this);

            cursors.right.onDown.add(function() {
                var targetX = knight.targetX + TILE_WIDTH;
                var targetY = knight.targetY;
                return move(targetX, targetY, 'right');
            }, this);

            cursors.up.onDown.add(function() {
                var targetX = knight.targetX;
                var targetY = knight.targetY - TILE_WIDTH;
                return move(targetX, targetY, 'up');
            }, this);

            cursors.down.onDown.add(function() {
                var targetX = knight.targetX;
                var targetY = knight.targetY + TILE_WIDTH;
                return move(targetX, targetY, 'down');
            }, this);
        }

        function isMoving() {
            return (
                knight.body.x != knight.targetX
                || knight.body.y != knight.targetY
            );
        }

        function getTileProperties(x, y) {

            var x = forgroundLayer.getTileX(x);
            var y = forgroundLayer.getTileY(y);

            var tile = map.getTile(x, y, forgroundLayer);

            // Note: JSON.stringify will convert the object tile properties to a string
            currentDataString = JSON.stringify( tile.properties );

        }

        function isWall(x, y) {

            var x = wallLayer.getTileX(x);
            var y = wallLayer.getTileY(y);

            var tile = map.getTile(x, y, wallLayer);

            // Note: JSON.stringify will convert the object tile properties to a string
            return tile != null;

        }

        function getTilePropertiesFromPointer() {

            var x = (game.input.activePointer.worldX);
            var y = (game.input.activePointer.worldY);

            return getTileProperties(x, y);
        }

        function updateMarker() {

            marker.x = forgroundLayer.getTileX(game.input.activePointer.worldX) * TILE_WIDTH ;
            marker.y = forgroundLayer.getTileY(game.input.activePointer.worldY) * TILE_WIDTH ;

        }

        function update() {
            if (!isMoving()){
                knight.animations.stop()
            }

            newBatteryState = updateBatteryUI();
            if (oldBatteryState != newBatteryState) {
                oldBatteryState = newBatteryState;
                if (newBatteryState == 'Charging') {
                    door.animations.play('open');
                } else if (newBatteryState == 'Discharging') {
                    door.animations.play('close');
                }
            }

        }

        function render() {

            if(currentDataString){
                game.debug.text('Tile properties: ' + currentDataString, TILE_WIDTH, 550);
            } else {
                game.debug.text("Click on a tile to reveal the properties of the tile", TILE_WIDTH, 550);
            }
        }

    </script>
</html>
